In R, there are three object oriented systems: S3, S4 and R5.

-------------------------------- S3 ---------------------------------

S3 imlements generic-function OO

The class of an object is determined through the class attributes:
	x <- 1
	attr(x,"class") <- "foo" --> now x is of class foo

In one line:
	x <- structure(1, class="foo")
or 
	class(x) <- "foo"  --> better to use class() for setting class(es)

In this way, we can turn any object into an object f class foo
Actually, objects are not limited to a single class and can have
multiple classes:
	class(x) <- c("a","b")

One we call a method for x, then R first look for that method in a,
if it falls it moves to b
--> the order in which classes are listed determined which method
will be actually called, i.e. the order matters
--> S3 does not define any relationship between classes,
actually neither a definition of what a class is
--> much freedom for the user, maybe even too much...

To call a method, we need to declare a generic function:
	<function_name> <- function(<inputs>) {
		UseMethod("<method_to_call>",<object>)
	}
Then, we can call, e.g.:
	<function_name>(x)
UseMethod figures out which method to call by going through
all the classes the object x is a class of

Note: to declare a class method, first put the name of the method,
then the name of the class, separated by a dot, e.g.
	mean.foo <- function(x) sum(x) / length(x)
--> I think that for single-statement methods, brackets can be omitted

Example:
	x <- structure(1, class = letters)
	bar <- function(x) UseMethod("bar", x)
	bar.z <- function(x) "z"
	bar(x)
	# [1] "z"
Here, bar is a generic function
Note that one can directly call the method bar.z(x), but in this way
the benefit of having a generic function is not exploited

IMPORTANT: in R, methods are associated with functions, not classes!

To know which methods a generic function has accessed to, use methods:
	methods("<name_generic_function>")
	
-------------------------------- S4 ---------------------------------

S4 is much more closer to classic OO classes than S3 does
Two main differences between S4 and S3:
- formal definition of classes
- multiple dispatch (maybe see later...)

Each class is characterized by three components:
- the name (alphanumeric string)
- the representation, i.e. the name and class of attributes (or slots)
- a character vector of classes it inherits (contains)
A class is declared through setClass:
	setClass("Person", representation(name = "character", age = "numeric"))
	setClass("Employee", representation(boss = "Person"), contains = "Person")
and instances are created through new:
	hadley <- new("Person", name = "Hadley", age = 31)
	
Notes: 
- if the name or type of an attribute is wrong at instantiation time,
  R throws an error
- if a slot is not declared, it is given a default value

To access the attribute of a class:
	- hadley@age
	- slot(hadley,"age")
	
We can also set user-defined defalt values for attributes:
	setClass("Person", representation(name = "character", age = "numeric"), 
  		prototype(name = NA_character_, age = NA_real_))
To get a description of all methods: use getSlots
	getSlots("Person") --> name of the class, not of the object
	
Multiple calls to setClass with the same class name will be overridden by 
the last call, unless using
	sealed = TRUE
at first call

We can also add a function checking the validity of a just-created object:
this function must takes only one input argument, called object,
and return a string saying why the object is not valid (if needed)
Then, in class declaration:
	setClass("Person", representation(name = "character", age = "numeric"), 
  		validity = check_person)
Note however that the checks are not performed when we directly modify
attributes after the instantiation; to force check:
	validObject(hadley)
